---
phase: 02-foundation-types
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/mocks/marketMocks.ts
autonomous: true

must_haves:
  truths:
    - "Mock market generator creates valid Market objects with realistic data"
    - "Mock position generator creates valid Position objects with P&L calculations"
    - "Mock trade generator creates valid Trade objects"
    - "All mock data uses trading vocabulary, not betting vocabulary"
    - "Mock utilities can generate lists of varying sizes"
  artifacts:
    - path: "src/mocks/marketMocks.ts"
      provides: "Mock data generation utilities for development and testing"
      exports: ["createMockMarket", "createMockPosition", "createMockTrade", "createMockMarkets", "createMockPositions"]
  key_links:
    - from: "src/mocks/marketMocks.ts"
      to: "src/types/market.ts"
      via: "type imports"
      pattern: "import.*Market.*Position.*Trade.*from.*@/types/market"
---

<objective>
Create mock data generation utilities for prediction market development and testing.

Purpose: Enable Phase 3 (Mock Trading UI) to build and iterate on UI components without external API dependency. Mock data must be realistic enough to exercise all UI states (open markets, closed markets, winning positions, losing positions).

Output:
- src/mocks/marketMocks.ts with factory functions for all market domain types
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md

# Types from Plan 01
@src/types/market.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock data generation utilities</name>
  <files>src/mocks/marketMocks.ts</files>
  <action>
Create comprehensive mock data factory functions.

File: `src/mocks/marketMocks.ts`

```typescript
import type {
  Market,
  MarketOutcome,
  MarketStatus,
  Position,
  Trade,
  OrderSide,
} from '@/types/market';

// ============================================
// Helper utilities
// ============================================

let idCounter = 1;
const generateId = () => `mock-${idCounter++}`;

const randomBetween = (min: number, max: number) =>
  Math.random() * (max - min) + min;

const randomInt = (min: number, max: number) =>
  Math.floor(randomBetween(min, max));

const randomElement = <T>(arr: T[]): T =>
  arr[Math.floor(Math.random() * arr.length)];

// ============================================
// Sample data for realistic mocks
// ============================================

const MARKET_QUESTIONS = [
  'Will BTC exceed $100,000 by end of Q1 2025?',
  'Will India win the Cricket World Cup 2025?',
  'Will Ethereum 2.0 staking yield exceed 5% APY?',
  'Will TON reach 500M daily active users by 2025?',
  'Will SpaceX launch Starship to orbit before July 2025?',
  'Will OpenAI release GPT-5 before March 2025?',
  'Will the US Federal Reserve cut rates in January 2025?',
  'Will Tesla deliver 2M vehicles in Q1 2025?',
];

const CATEGORIES = ['Crypto', 'Sports', 'Tech', 'Finance', 'Science'];

// ============================================
// Factory: Market Outcome
// ============================================

export function createMockOutcome(
  overrides: Partial<MarketOutcome> = {}
): MarketOutcome {
  const probability = overrides.probability ?? randomBetween(0.1, 0.9);
  return {
    id: generateId(),
    label: 'Yes',
    probability,
    totalShares: randomInt(1000, 100000),
    ...overrides,
  };
}

// ============================================
// Factory: Market
// ============================================

export interface CreateMockMarketOptions {
  status?: MarketStatus;
  outcomeCount?: number;
  question?: string;
}

export function createMockMarket(
  options: CreateMockMarketOptions = {}
): Market {
  const {
    status = 'open',
    outcomeCount = 2,
    question = randomElement(MARKET_QUESTIONS),
  } = options;

  // Generate outcomes with probabilities that sum to ~1
  const outcomes: MarketOutcome[] = [];
  let remainingProb = 1;

  for (let i = 0; i < outcomeCount; i++) {
    const isLast = i === outcomeCount - 1;
    const prob = isLast
      ? remainingProb
      : randomBetween(0.1, remainingProb - 0.1 * (outcomeCount - i - 1));
    remainingProb -= prob;

    outcomes.push(
      createMockOutcome({
        id: generateId(),
        label: outcomeCount === 2 ? (i === 0 ? 'Yes' : 'No') : `Option ${i + 1}`,
        probability: Math.round(prob * 100) / 100,
      })
    );
  }

  const now = new Date();
  const endTime = new Date(now.getTime() + randomInt(1, 30) * 24 * 60 * 60 * 1000);

  return {
    id: generateId(),
    question,
    description: `Market for: ${question}`,
    category: randomElement(CATEGORIES),
    outcomes,
    volume: randomInt(10000, 1000000),
    liquidity: randomInt(5000, 500000),
    endTime: endTime.toISOString(),
    status,
    resolvedOutcomeId: status === 'resolved' ? outcomes[0].id : undefined,
    createdAt: new Date(now.getTime() - randomInt(1, 30) * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: now.toISOString(),
  };
}

/**
 * Generate multiple mock markets
 */
export function createMockMarkets(
  count: number,
  options: CreateMockMarketOptions = {}
): Market[] {
  return Array.from({ length: count }, () => createMockMarket(options));
}

// ============================================
// Factory: Position
// ============================================

export interface CreateMockPositionOptions {
  marketId?: string;
  outcomeId?: string;
  profitable?: boolean;
}

export function createMockPosition(
  options: CreateMockPositionOptions = {}
): Position {
  const { marketId, outcomeId, profitable } = options;

  const shares = randomInt(10, 1000);
  const avgCostBasis = randomBetween(0.2, 0.8);

  // Determine if position is profitable
  const isProfitable = profitable ?? Math.random() > 0.4;
  const priceChange = isProfitable
    ? randomBetween(0.05, 0.3)
    : randomBetween(-0.3, -0.05);
  const currentPrice = Math.max(0.01, Math.min(0.99, avgCostBasis + priceChange));

  const currentValue = shares * currentPrice;
  const costBasisTotal = shares * avgCostBasis;
  const unrealizedPnl = currentValue - costBasisTotal;

  return {
    id: generateId(),
    marketId: marketId ?? generateId(),
    outcomeId: outcomeId ?? generateId(),
    shares,
    avgCostBasis: Math.round(avgCostBasis * 100) / 100,
    currentPrice: Math.round(currentPrice * 100) / 100,
    currentValue: Math.round(currentValue * 100) / 100,
    unrealizedPnl: Math.round(unrealizedPnl * 100) / 100,
    realizedPnl: 0,
  };
}

/**
 * Generate multiple mock positions
 */
export function createMockPositions(
  count: number,
  options: CreateMockPositionOptions = {}
): Position[] {
  return Array.from({ length: count }, () => createMockPosition(options));
}

// ============================================
// Factory: Trade
// ============================================

export interface CreateMockTradeOptions {
  marketId?: string;
  outcomeId?: string;
  side?: OrderSide;
  status?: Trade['status'];
}

export function createMockTrade(
  options: CreateMockTradeOptions = {}
): Trade {
  const {
    marketId,
    outcomeId,
    side = randomElement(['buy', 'sell'] as OrderSide[]),
    status = 'confirmed',
  } = options;

  const shares = randomInt(10, 500);
  const pricePerShare = randomBetween(0.1, 0.9);
  const totalCost = shares * pricePerShare;

  return {
    id: generateId(),
    marketId: marketId ?? generateId(),
    outcomeId: outcomeId ?? generateId(),
    side,
    shares,
    pricePerShare: Math.round(pricePerShare * 100) / 100,
    totalCost: Math.round(totalCost * 100) / 100,
    timestamp: new Date(Date.now() - randomInt(0, 7) * 24 * 60 * 60 * 1000).toISOString(),
    txHash: status === 'confirmed' ? `0x${Array(64).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join('')}` : undefined,
    status,
  };
}

/**
 * Generate multiple mock trades
 */
export function createMockTrades(
  count: number,
  options: CreateMockTradeOptions = {}
): Trade[] {
  return Array.from({ length: count }, () => createMockTrade(options));
}

// ============================================
// Composite: Market with Positions
// ============================================

export interface MockMarketWithPositions {
  market: Market;
  positions: Position[];
}

/**
 * Create a market with associated positions for a user
 */
export function createMockMarketWithPositions(
  positionCount = 1
): MockMarketWithPositions {
  const market = createMockMarket();
  const positions = market.outcomes
    .slice(0, positionCount)
    .map((outcome) =>
      createMockPosition({
        marketId: market.id,
        outcomeId: outcome.id,
      })
    );

  return { market, positions };
}

// ============================================
// Reset ID counter (for tests)
// ============================================

export function resetMockIdCounter() {
  idCounter = 1;
}
```

Key design decisions:
- Factory pattern with optional overrides for test flexibility
- Probability normalization ensures outcomes sum to ~1
- Trading vocabulary throughout (shares, position, cost basis - NOT bet, stake, odds)
- Realistic sample questions covering crypto, sports, tech, finance
- P&L calculations are mathematically correct
- Mock transaction hashes for blockchain integration testing
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass with no type errors.
Verify file exists with `ls -la src/mocks/marketMocks.ts`.

Test the mocks work by creating a quick test file or running in Node:
```bash
npx tsx -e "
const { createMockMarket, createMockPosition, createMockMarkets } = require('./src/mocks/marketMocks');
console.log('Market:', JSON.stringify(createMockMarket(), null, 2));
console.log('\\nPositions:', JSON.stringify(createMockPosition(), null, 2));
console.log('\\n5 Markets:', createMockMarkets(5).map(m => m.question));
"
```
  </verify>
  <done>
- src/mocks/marketMocks.ts exists
- Exports: createMockMarket, createMockPosition, createMockTrade, createMockMarkets, createMockPositions, createMockMarketWithPositions
- All generated data uses trading vocabulary (shares, position, cost basis)
- TypeScript compilation passes
- Mock data is realistic and mathematically valid
  </done>
</task>

</tasks>

<verification>
After task completes:

1. TypeScript compiles:
```bash
npx tsc --noEmit
# Should pass with no errors
```

2. File exists:
```bash
ls -la src/mocks/marketMocks.ts
# File should exist
```

3. Build succeeds:
```bash
npm run build
# Should complete successfully
```

4. Quick functional test (optional):
```bash
npx tsx -e "const m = require('./src/mocks/marketMocks'); console.log(m.createMockMarket())"
```
</verification>

<success_criteria>
- src/mocks/marketMocks.ts exists with all factory functions
- All mock data types match the types in src/types/market.ts
- Mock data uses trading vocabulary consistently
- TypeScript compilation passes
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-foundation-types/02-03-SUMMARY.md`
</output>
