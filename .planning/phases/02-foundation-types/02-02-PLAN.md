---
phase: 02-foundation-types
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/stores/tradeStore.ts
  - src/lib/queryClient.ts
  - src/providers/QueryProvider.tsx
  - src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "TradeStore manages trade slip draft state with add/update/clear actions"
    - "QueryClient is configured with appropriate stale times for market data"
    - "QueryProvider wraps the app and provides query context"
    - "App layout includes QueryProvider in the provider hierarchy"
  artifacts:
    - path: "src/stores/tradeStore.ts"
      provides: "Zustand store for trade slip state"
      exports: ["useTradeStore"]
    - path: "src/lib/queryClient.ts"
      provides: "TanStack Query client configuration"
      exports: ["queryClient"]
    - path: "src/providers/QueryProvider.tsx"
      provides: "React Query provider component"
      exports: ["QueryProvider"]
    - path: "src/app/layout.tsx"
      provides: "Root layout with QueryProvider"
      contains: "QueryProvider"
  key_links:
    - from: "src/stores/tradeStore.ts"
      to: "src/types/market.ts"
      via: "type import"
      pattern: "import.*TradeSlip.*from.*@/types/market"
    - from: "src/app/layout.tsx"
      to: "src/providers/QueryProvider.tsx"
      via: "component import"
      pattern: "import.*QueryProvider.*from.*@/providers/QueryProvider"
---

<objective>
Create Zustand trade store, TanStack Query configuration, and wire the QueryProvider into the app layout.

Purpose: Establish the state management infrastructure that trading UI components will use. Zustand handles client state (trade slip), TanStack Query handles server state (markets, positions).

Output:
- src/stores/tradeStore.ts with trade slip management
- src/lib/queryClient.ts with configured QueryClient
- src/providers/QueryProvider.tsx wrapping the app
- Updated src/app/layout.tsx with QueryProvider
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md

# Types from Plan 01
@src/types/market.ts

# Existing patterns to follow
@src/context/InfoContext.tsx
@src/hooks/useTelegram.tsx
@src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand trade store</name>
  <files>src/stores/tradeStore.ts</files>
  <action>
Create a Zustand store for managing trade slip state.

File: `src/stores/tradeStore.ts`

```typescript
'use client';

import { create } from 'zustand';
import type { TradeSlip, Market, OrderSide } from '@/types/market';

interface TradeState {
  // Current trade slip (null if no active trade)
  tradeSlip: TradeSlip | null;

  // Actions
  openTradeSlip: (marketId: string, outcomeId: string, side: OrderSide, market?: Market) => void;
  updateShares: (shares: number) => void;
  updateSide: (side: OrderSide) => void;
  clearTradeSlip: () => void;

  // Computed helpers (for components)
  hasActiveSlip: () => boolean;
}

export const useTradeStore = create<TradeState>((set, get) => ({
  tradeSlip: null,

  openTradeSlip: (marketId, outcomeId, side, market) => {
    set({
      tradeSlip: {
        marketId,
        market,
        outcomeId,
        side,
        shares: 0,
        estimatedCost: 0,
        estimatedAvgPrice: 0,
      },
    });
  },

  updateShares: (shares) => {
    const current = get().tradeSlip;
    if (!current) return;

    // Estimated cost calculation will be enhanced when we have market data
    // For now, use a simple calculation
    const outcome = current.market?.outcomes.find(o => o.id === current.outcomeId);
    const price = outcome?.probability ?? 0.5;
    const estimatedCost = shares * price;

    set({
      tradeSlip: {
        ...current,
        shares,
        estimatedCost,
        estimatedAvgPrice: price,
      },
    });
  },

  updateSide: (side) => {
    const current = get().tradeSlip;
    if (!current) return;
    set({
      tradeSlip: { ...current, side },
    });
  },

  clearTradeSlip: () => {
    set({ tradeSlip: null });
  },

  hasActiveSlip: () => get().tradeSlip !== null,
}));
```

Key design decisions:
- Use 'use client' directive (Zustand is client-side only)
- TradeSlip holds optional Market reference for price lookups
- Actions are atomic and self-contained
- No persistence to localStorage yet (add in Phase 3 if needed)
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass with no type errors.
Verify file exists with `ls -la src/stores/tradeStore.ts`.
  </verify>
  <done>
- src/stores/tradeStore.ts exists
- useTradeStore exported as named export
- Store has tradeSlip state and all actions (openTradeSlip, updateShares, updateSide, clearTradeSlip, hasActiveSlip)
- TypeScript compilation passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TanStack Query client and provider</name>
  <files>src/lib/queryClient.ts, src/providers/QueryProvider.tsx</files>
  <action>
Create TanStack Query client configuration and provider component.

File 1: `src/lib/queryClient.ts`

```typescript
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Market data should be relatively fresh
      staleTime: 1000 * 30, // 30 seconds

      // Keep in cache for 5 minutes
      gcTime: 1000 * 60 * 5,

      // Retry failed requests once
      retry: 1,

      // Don't refetch on window focus for mobile app experience
      refetchOnWindowFocus: false,

      // Don't refetch on reconnect automatically
      refetchOnReconnect: false,
    },
    mutations: {
      // Retry mutations once on failure
      retry: 1,
    },
  },
});
```

Key configuration decisions per research:
- 30s staleTime: Market data needs freshness but not real-time (polling handles real-time)
- refetchOnWindowFocus: false - Telegram Mini App switches context frequently
- gcTime: 5 minutes - Keep data cached for smooth navigation

File 2: `src/providers/QueryProvider.tsx`

```typescript
'use client';

import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '@/lib/queryClient';

export function QueryProvider({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
```

Follow existing provider pattern from InfoContext.tsx and useTelegram.tsx:
- 'use client' directive
- Simple wrapper component
- Children pass-through
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass with no type errors.
Verify files exist:
- `ls -la src/lib/queryClient.ts`
- `ls -la src/providers/QueryProvider.tsx`
  </verify>
  <done>
- src/lib/queryClient.ts exists with configured QueryClient
- src/providers/QueryProvider.tsx exists with QueryClientProvider wrapper
- Both export their main exports (queryClient, QueryProvider)
- TypeScript compilation passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire QueryProvider into app layout</name>
  <files>src/app/layout.tsx</files>
  <action>
Add QueryProvider to the root layout's provider hierarchy.

Modify `src/app/layout.tsx`:

1. Import QueryProvider:
```typescript
import { QueryProvider } from '@/providers/QueryProvider';
```

2. Add QueryProvider to the provider hierarchy.

The existing provider order is:
- TonProvider (outermost)
- TelegramProvider
- InfoProvider (innermost)

Add QueryProvider OUTSIDE InfoProvider but INSIDE TelegramProvider (it doesn't depend on Telegram, but components using it may need Telegram context):

```tsx
<TonProvider>
  <TelegramProvider>
    <QueryProvider>
      <InfoProvider>
        {children}
        <BottomNav />
      </InfoProvider>
    </QueryProvider>
  </TelegramProvider>
</TonProvider>
```

Do NOT modify any other part of layout.tsx. Preserve all existing imports, metadata, and styling.
  </action>
  <verify>
Run `npm run build` - should complete without errors.
Run `npm run dev` and visit http://localhost:3000 - app should load without errors.
Check browser console for React Query devtools initialization (no errors).
  </verify>
  <done>
- src/app/layout.tsx imports QueryProvider
- QueryProvider wraps InfoProvider and children
- Provider hierarchy: TonProvider > TelegramProvider > QueryProvider > InfoProvider
- Build succeeds
- Dev server loads without errors
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles:
```bash
npx tsc --noEmit
# Should pass with no errors
```

2. Build succeeds:
```bash
npm run build
# Should complete successfully
```

3. Dev server runs:
```bash
npm run dev
# App loads at localhost:3000 without errors
```

4. Files exist:
```bash
ls -la src/stores/tradeStore.ts
ls -la src/lib/queryClient.ts
ls -la src/providers/QueryProvider.tsx
```

5. Imports work (manual verification in any component):
```typescript
import { useTradeStore } from '@/stores/tradeStore';
import { useQuery } from '@tanstack/react-query';
```
</verification>

<success_criteria>
- src/stores/tradeStore.ts exports useTradeStore with trade slip management
- src/lib/queryClient.ts exports configured queryClient
- src/providers/QueryProvider.tsx exports QueryProvider component
- src/app/layout.tsx includes QueryProvider in provider hierarchy
- Build and dev server run without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-foundation-types/02-02-SUMMARY.md`
</output>
